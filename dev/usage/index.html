<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · TPLib.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TPLib.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Representing-tropical-numbers"><span>Representing tropical numbers</span></a></li><li><a class="tocitem" href="#Compute-rays-of-a-tropical-cone"><span>Compute rays of a tropical cone</span></a></li><li><a class="tocitem" href="#Compute-rays-of-the-tropical-polar-cone"><span>Compute rays of the tropical polar cone</span></a></li><li><a class="tocitem" href="#Compute-halfspaces"><span>Compute halfspaces</span></a></li><li><a class="tocitem" href="#Compute-tropical-complex"><span>Compute tropical complex</span></a></li><li><a class="tocitem" href="#Compute-tangent-hypergraph"><span>Compute tangent hypergraph</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTPLib/TPLib.jl/blob/main/docs/src/usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-TPLib"><a class="docs-heading-anchor" href="#Using-TPLib">Using TPLib</a><a id="Using-TPLib-1"></a><a class="docs-heading-anchor-permalink" href="#Using-TPLib" title="Permalink"></a></h1><h2 id="Representing-tropical-numbers"><a class="docs-heading-anchor" href="#Representing-tropical-numbers">Representing tropical numbers</a><a id="Representing-tropical-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-tropical-numbers" title="Permalink"></a></h2><p>Tropical elements are represented as the type <code>MaxPlus{T}</code> or <code>MinPlus{T}</code> where <code>{T &lt;: Number}</code> depending on wether they are elements of the max-plus semiring <span>$(\mathbb{R} \cup \{-\infty\},\max{},+)$</span> or the min-plus semiring <span>$(\mathbb{R} \cup \{+\infty\},\min{},+)$</span>. The types <code>MaxPlus{T}</code> and <code>MinPlus{T}</code> are both subtypes of <code>SemiRing{T}</code>. They contain a field accessible through the function <a href="../reference/#TPLib.Tropical.elt"><code>elt</code></a> which is either an element of <code>T</code>, or an element of type <code>Infinite</code> representing the tropical zero. This element is denoted <code>∞</code> in both tropical semirings, and is displayed <code>·</code> in the REPL. The function <a href="../reference/#TPLib.Tropical.isinfinite"><code>isinfinite(x)</code></a> returns <code>true</code> if <code>x</code> is the tropical zero of the field.</p><p>Tropical elements are constructed either by providing explicitely the type <a href="../reference/#TPLib.Tropical.MaxPlus"><code>MaxPlus{T}(x)</code></a> or <a href="../reference/#TPLib.Tropical.MinPlus"><code>MinPlus{T}(x)</code></a>, in which case <code>x</code> is converted to type <code>T</code> or to <code>∞</code> (the latter is done even if <code>x</code> is an infinite element which cannot be converted to type <code>T</code>, for instance <code>MaxPlus{Int64}(-Inf)</code>), or simply with <a href="../reference/#TPLib.Tropical.MaxPlus"><code>MaxPlus(x)</code></a> or <a href="../reference/#TPLib.Tropical.MinPlus"><code>MinPlus(x)</code></a>, in which case <code>T</code> is inferred from the type of <code>x</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; MaxPlus(4.)
4.0
julia&gt; MinPlus{Rational}(5)
5//1
julia&gt; MaxPlus{Int64}(-Inf) == MaxPlus{Int64}(∞)
true</code></pre><p>Addition <a href="../reference/#Base.:+"><code>+</code></a> and multiplication <a href="../reference/#Base.:*"><code>*</code></a> of elements of type <code>SemiRing{T}</code> are the tropical operations <code>max/min</code> and <code>+</code> respectively. Conversion between elements of type <code>SemiRing{T}</code> and of type <code>T</code> or <code>Infinite</code> is done automatically. </p><pre><code class="language-julia-repl hljs">julia&gt; MaxPlus(4.) + MaxPlus(-6)
4.0
julia&gt; MinPlus(6.) * 4
10.0
julia&gt; MaxPlus(8//3) * -Inf == MaxPlus{Rational}(∞)
true</code></pre><p>The rest of the guide will use mostly the max-plus semiring. The arguments of all functions can be arrays of type <code>SemiRing{T}</code>, in which case the tropical operation <code>+</code> will be infered from the type of the semiring, or can be arrays of type <code>T&lt;:Number</code>. In this case, an additional argument can be given, either <code>:max</code> or <code>:min</code>, to specify if the conversion should be done towards <code>MaxPlus{T}</code> or <code>MinPlus{T}</code>. Otherwise, it defaults to <code>:max</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; I = [3 ∞ 5 4 2 ∞]</code><code class="nohighlight hljs ansi" style="display:block;">1×6 Matrix{Number}:
 3  ⋅  5  4  2  ⋅</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(I,3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{MaxPlus{Int64}}:
 0  ⋅  -1
 ⋅  0  -3
 ⋅  ⋅   0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(I,3,:min)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{MinPlus{Int64}}:
 0  1   ⋅
 ⋅  0  -3
 ⋅  0   ⋅</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(convert(Matrix{MaxPlus{Int64}},I),3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{MaxPlus{Int64}}:
 0  ⋅  -1
 ⋅  0  -3
 ⋅  ⋅   0</code></pre><p>You could also write <code>-Inf</code> instead of <code>∞</code> in <code>I</code> for the max-plus ring, or <code>Inf</code> for the min-plus ring. This however would change the type of <code>I</code> to <code>Matrix{Float64}</code>, and therefore the result would be of type <code>Matrix{MaxPlus{Float64}}</code> instead of <code>Matrix{MaxPlus{Int64}}</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; I = [3 -Inf 5 4 2 -Inf]</code><code class="nohighlight hljs ansi" style="display:block;">1×6 Matrix{Float64}:
 3.0  -Inf  5.0  4.0  2.0  -Inf</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(I,3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{MaxPlus{Float64}}:
 0.0    ⋅  -1.0
   ⋅  0.0  -3.0
   ⋅    ⋅   0.0</code></pre><p>To prevent this, you can convert beforehand the matrix <code>I</code> to the type <code>Matrix{MaxPlus{Int64}}</code>. The <code>-Inf</code> will be converted to <code>∞</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Matrix{MaxPlus{Int64}}, I)</code><code class="nohighlight hljs ansi" style="display:block;">1×6 Matrix{MaxPlus{Int64}}:
 3  ⋅  5  4  2  ⋅</code></pre><h2 id="Compute-rays-of-a-tropical-cone"><a class="docs-heading-anchor" href="#Compute-rays-of-a-tropical-cone">Compute rays of a tropical cone</a><a id="Compute-rays-of-a-tropical-cone-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-rays-of-a-tropical-cone" title="Permalink"></a></h2><p>Given a tropical cone in <span>$\mathbb{T}^n$</span> described by the inequalities  <span>$\max(a_{i1} + x_1, \dots, a_{in} + x_n) \geqslant \max(b_{i1} + x_1, \dots, b_{in} + x_n)$</span> for <span>$i \in [m]$</span> regrouped in the matrix <code>I</code> with <code>m</code> rows and <code>2n</code>columns, the function <a href="../reference/#TPLib.compute_ext_rays"><code>compute_ext_rays(I,n)</code></a> returns a matrix <code>G</code> whose rows are the minimal family of generators of the cone. For example, consider the cone in <span>$\mathbb{T}^5$</span> defined by the inequalities</p><p class="math-container">\[\max(x_2 + 2, x_3 - 1, x_4 + 4) \geqslant \max(x_1 + 2, x_2 + 2, x_4 + 4, x_5 + 2) \\
\max(x_1 + 1, x_3 + 4, x_4 + 5, x_5 + 4) \geqslant \max(x_2 + 4, x_4 + 5, x_5 + 4)\]</p><p>Then the matrix representation of the system and the computation are as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; I = [∞ 2 -1 4 ∞ 2 2 ∞ 4 2;
           1 ∞ 4 5 4 ∞ 4 ∞ 5 4]</code><code class="nohighlight hljs ansi" style="display:block;">2×10 Matrix{Number}:
 ⋅  2  -1  4  ⋅  2  2  ⋅  4  2
 1  ⋅   4  5  4  ⋅  4  ⋅  5  4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(I,5)</code><code class="nohighlight hljs ansi" style="display:block;">11×5 Matrix{MaxPlus{Int64}}:
 0  0  0   ⋅   ⋅
 0  0  ⋅   ⋅   0
 ⋅  ⋅  ⋅   0   2
 0  ⋅  ⋅  -2   ⋅
 ⋅  ⋅  0   ⋅  -3
 0  ⋅  3   ⋅   ⋅
 ⋅  ⋅  0   ⋅   ⋅
 ⋅  ⋅  ⋅   0   ⋅
 ⋅  0  ⋅   ⋅   0
 ⋅  0  ⋅  -1   ⋅
 ⋅  0  0   ⋅   ⋅</code></pre><h2 id="Compute-rays-of-the-tropical-polar-cone"><a class="docs-heading-anchor" href="#Compute-rays-of-the-tropical-polar-cone">Compute rays of the tropical polar cone</a><a id="Compute-rays-of-the-tropical-polar-cone-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-rays-of-the-tropical-polar-cone" title="Permalink"></a></h2><p>Specifying a cone by a set of generators <code>M</code> in dimension <code>n</code>, the function <a href="../reference/#TPLib.compute_ext_rays_polar"><code>compute_ext_rays_polar(M,n)</code></a> returns the generators of the tropical polar cone. For example, consider the cone in <span>$\mathbb{T}^5$</span> which is the tropical cone generated by</p><p class="math-container">\[\operatorname{tcone}(v_1, v_2, v_3) \\\]</p><p class="math-container">\[\text{where } v_1 = \begin{pmatrix} -\infty \\ 4 \\ 2 \\ 3 \\ 4 \end{pmatrix}, v_2 = \begin{pmatrix} 4 \\ -\infty \\ -5 \\ 4 \\ -1 \end{pmatrix}, v_3 = \begin{pmatrix} -\infty \\ -\infty \\ 2 \\ 3 \\ -1 \end{pmatrix}\]</p><p>The generators are represented as the matrix</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = [∞ 4 2 3 4; 4 ∞ -5 4 -1; ∞ ∞ 2 3 -1]</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Matrix{Number}:
 ⋅  4   2  3   4
 4  ⋅  -5  4  -1
 ⋅  ⋅   2  3  -1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays_polar(M,5)</code><code class="nohighlight hljs ansi" style="display:block;">29×10 Matrix{MaxPlus{Int64}}:
 -7  ⋅   0   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅  -2
 -5  0  -3   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅   0
  0  ⋅   ⋅   ⋅  ⋅   0   ⋅  ⋅   ⋅   ⋅
 -4  ⋅   ⋅   ⋅  0   ⋅   ⋅  ⋅  -4   ⋅
 -1  ⋅   0   ⋅  ⋅   ⋅   ⋅  ⋅  -1   ⋅
  ⋅  ⋅   0   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅  -4
  ⋅  ⋅   0   ⋅  ⋅  -9   ⋅  ⋅   ⋅   ⋅
  ⋅  ⋅   0   ⋅  ⋅   ⋅   ⋅  ⋅  -9   ⋅
  ⋅  ⋅   0  -7  ⋅   ⋅   ⋅  ⋅   ⋅  -2
  ⋅  0  -3  -5  ⋅   ⋅   ⋅  ⋅   ⋅   0
  ⋮                 ⋮
  ⋅  ⋅   0   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅   ⋅
  ⋅  0   ⋅   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅   ⋅
  0  ⋅   ⋅   ⋅  ⋅   ⋅   ⋅  ⋅   ⋅   ⋅
  ⋅  0   ⋅   ⋅  ⋅   ⋅   0  ⋅   ⋅   ⋅
  ⋅  0   ⋅  -4  ⋅   ⋅   ⋅  ⋅   ⋅   0
  ⋅  ⋅   0   ⋅  ⋅   ⋅  -2  ⋅   ⋅   ⋅
  ⋅  ⋅   ⋅   0  ⋅   ⋅  -1  ⋅   ⋅   ⋅
  ⋅  ⋅   ⋅   0  ⋅   ⋅   ⋅  ⋅   ⋅  -1
  ⋅  ⋅   ⋅   ⋅  0   ⋅   0  ⋅   ⋅   ⋅</code></pre><p>Because of the absence of a minus operation for tropical numbers, the polar of a cone in <span>$\mathbb{T}^n$</span> lies in <span>$\mathbb{T}^{2n}$</span>, therefore the output of the function is a matrix with <code>2n</code> columns.</p><p>As another example, we can compute a minimal family of generators of a tropical cone by computing generators of the tropical polar cone, which are equations for the halfspaces defining the tropical cone, and then computing the rays of the tropical cone using these equations. For example, consider the tropical cone in <span>$\mathbb{T}^3$</span> defined by the generators</p><p class="math-container">\[\operatorname{tcone}(v_1, v_2, v_3, v_4, v_5)\]</p><p class="math-container">\[\text{where } v_1 = \begin{pmatrix} 0 \\ 4 \\ 0 \end{pmatrix}, \, v_2 = \begin{pmatrix} 0 \\ 3 \\ 4 \end{pmatrix} , \, v_3 = \begin{pmatrix} 0 \\ 0 \\ 2 \end{pmatrix} , \, v_4 = \begin{pmatrix} 0 \\ 4 \\ 2 \end{pmatrix} , \, v_5 = \begin{pmatrix} 0 \\ 3 \\ 3 \end{pmatrix} .\]</p><p>Drawing the projection of the tropical cone in <span>$\mathbb{P}^2$</span>, we clearly see that it is equal to <span>$\operatorname{tcone}(v_1, v_2, v_3)$</span>.</p><p><img src="../fig.png" alt="img"/></p><p>Indeed, we have the computation</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = [0 4 0; 0 3 4; 0 0 2; 0 4 2; 0 3 3]</code><code class="nohighlight hljs ansi" style="display:block;">5×3 Matrix{Int64}:
 0  4  0
 0  3  4
 0  0  2
 0  4  2
 0  3  3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_ext_rays(compute_ext_rays_polar(M,3),3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{MaxPlus{Int64}}:
 0  3  4
 0  4  0
 0  0  2</code></pre><h2 id="Compute-halfspaces"><a class="docs-heading-anchor" href="#Compute-halfspaces">Compute halfspaces</a><a id="Compute-halfspaces-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-halfspaces" title="Permalink"></a></h2><p>Given a tropical cone defined by a generating set <code>M</code> in dimension <code>n</code>, <a href="../reference/#TPLib.compute_halfspaces"><code>compute_halfspaces(M,n)</code></a> returns a representation of the cone by means of sectors of halfspaces. A halfspace give by the row <span>$[h_{i1}, \dots, h_{in}]$</span> and the set of sectors <span>$J$</span> is the subset defined by the inequality</p><p class="math-container">\[ \max_{j \in J}(x_j - h_{ij}) \geqslant \max_{j \in [n] \setminus J}(x_j - h_{ij})\]</p><p>The point <span>$(h_{i1}, \dots, h_{in})$</span> is called the apex of the the halfspace. Considering the same tropical cone as the previous example with its minimal family of generators,</p><p class="math-container">\[\operatorname{tcone}(v_1, v_2, v_3)\]</p><p class="math-container">\[\text{where } v_1 = \begin{pmatrix} 0 \\ 4 \\ 0 \end{pmatrix}, \, v_2 = \begin{pmatrix} 0 \\ 3 \\ 4 \end{pmatrix} , \, v_3 = \begin{pmatrix} 0 \\ 0 \\ 2 \end{pmatrix} .\]</p><p>From the drawing above, we see that the tropical polytope is defined by five halfspaces, with apexes <span>$(0,0,2)$</span>, <span>$(0,1,2)$</span>, <span>$(0,4,4)$</span>, <span>$(0,4,2)$</span>, and <span>$(0,4,0)$</span>. Indeed, the compuation gives</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = [0 4 0; 0 3 4; 0 0 2]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
 0  4  0
 0  3  4
 0  0  2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_halfspaces(M,3))</code><code class="nohighlight hljs ansi" style="display:block;">(MaxPlus{Int64}[0 4 0; 0 4 2; 0 4 4; 0 0 2; 0 1 2], [[3], [2, 3], [1], [2], [1, 2]])</code></pre><h2 id="Compute-tropical-complex"><a class="docs-heading-anchor" href="#Compute-tropical-complex">Compute tropical complex</a><a id="Compute-tropical-complex-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-tropical-complex" title="Permalink"></a></h2><p>Given a tropical cone defined by a generating set <code>M</code> in dimension <code>n</code>, <a href="../reference/#TPLib.compute_tropical_complex"><code>compute_tropical_complex(M,n)</code></a> returns the tropical complex associated with the tropical cone, meaning a set of vertices and a set of maximal cells defined by their adjacency with the vertices. These cells give a decomposition of the tropical polytope in a polyhedral complex.</p><p>Returning to our example</p><p class="math-container">\[\operatorname{tcone}(v_1, v_2, v_3)\]</p><p class="math-container">\[\text{where } v_1 = \begin{pmatrix} 0 \\ 4 \\ 0 \end{pmatrix}, \, v_2 = \begin{pmatrix} 0 \\ 3 \\ 4 \end{pmatrix} , \, v_3 = \begin{pmatrix} 0 \\ 0 \\ 2 \end{pmatrix} .\]</p><p>this tropical cone can be decomposed in three maximal cells, the full dimensional one whose vertices are <span>$(0,1,2)$</span>, <span>$(0,3,4)$</span>, <span>$(0,4,4)$</span>, and <span>$(0,4,2)$</span>, as well as the two segments joining <span>$(0,0,2)$</span> to <span>$(0,1,2)$</span> and <span>$(0,4,0)$</span> to <span>$(0,4,2)$</span>. The computation yields</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = [0 4 0; 0 3 4; 0 0 2]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
 0  4  0
 0  3  4
 0  0  2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_tropical_complex(M,3))</code><code class="nohighlight hljs ansi" style="display:block;">(MaxPlus{Int64}[1 1 2; 1 4 2; 1 4 4; 1 3 4; 1 0 2; 1 4 0], [[1, 2, 3, 4], [1, 5], [2, 6]])</code></pre><p>Here is a more complex example. On the figure, the orange vertices are the tropical vertices of the tropical polytope. They form, along with the red vertices, the vertices of the polyhedral complex.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = [0 24 95; 0 41 -9; 0 56 27; 0 64 50; 0 10 -67; 0 -17 -16; 0 -23 44]</code><code class="nohighlight hljs ansi" style="display:block;">7×3 Matrix{Int64}:
 0   24   95
 0   41   -9
 0   56   27
 0   64   50
 0   10  -67
 0  -17  -16
 0  -23   44</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_tropical_complex(M,3))</code><code class="nohighlight hljs ansi" style="display:block;">(MaxPlus{Int64}[1 -23 48; 1 -23 44; 1 -17 44; 1 -17 54; 1 10 81; 1 10 44; 1 41 44; 1 41 95; 1 24 95; 1 10 -19; 1 10 -40; 1 34 -16; 1 13 -16; 1 10 -4; 1 41 27; 1 41 -9; 1 41 12; 1 10 -16; 1 -2 -16; 1 -17 -16; 1 56 27; 1 56 42; 1 56 44; 1 58 44; 1 10 -67; 1 56 95; 1 64 95; 1 64 50], [[1, 2, 3, 4], [5, 6, 7, 8, 9], [3, 4, 5, 6], [10, 11, 12, 13], [6, 7, 14, 15], [12, 13, 16, 17], [13, 14, 15, 17, 18], [14, 18, 19], [3, 6, 14, 19, 20], [15, 17, 21, 22], [22, 23, 24], [7, 15, 22, 23], [11, 25], [10, 13, 18], [23, 24, 26, 27, 28], [7, 8, 23, 26]])</code></pre><p><img src="../fig2.png" alt="img"/></p><h2 id="Compute-tangent-hypergraph"><a class="docs-heading-anchor" href="#Compute-tangent-hypergraph">Compute tangent hypergraph</a><a id="Compute-tangent-hypergraph-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-tangent-hypergraph" title="Permalink"></a></h2><p>The tangent hypergraph of a tropical cone in dimension <code>n</code> at point <code>P</code> can be computed using the function <a href="../reference/#TPLib.compute_tangent_hypergraph"><code>compute_tangent_hypergraph</code></a>. If the tropical cone is defined by a system of inequalities <code>I</code> or by generators <code>M</code>, then the usage is</p><pre><code class="language- hljs">compute_tangent_hypergraph(I,P,n)
compute_tangent_hypergraph(M,P,n)</code></pre><p>If the cone is defined by a a system of halfspaces <code>H</code> and their sectors <code>A</code>, then the usage is</p><pre><code class="language- hljs">compute_tangent_hypergraph(H,A,P,n)</code></pre><p>The function returns a tuple containing the number of vertices of the hypergraph, its hyperedges, and in the case where it is called with inequalities or halfspaces, then it also returns the inequalities or halfspaces associated with each halfspace.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; H = [0 1 4 8; 0 3 6 10; 0 3 7 11; 0 3 7 11; 0 4 8 12; 0 1 5 9; 0 1 2 6; 0 1 2 3; 0 1 3 5; 0 1 2 4; 0 1 2 4; 0 1 3 7; 0 2 4 7; 0 2 5 9; 0 1 3 6]</code><code class="nohighlight hljs ansi" style="display:block;">15×4 Matrix{Int64}:
 0  1  4   8
 0  3  6  10
 0  3  7  11
 0  3  7  11
 0  4  8  12
 0  1  5   9
 0  1  2   6
 0  1  2   3
 0  1  3   5
 0  1  2   4
 0  1  2   4
 0  1  3   7
 0  2  4   7
 0  2  5   9
 0  1  3   6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [[2, 4], [1, 4], [1, 3], [1, 4], [1], [2], [3], [4], [1, 4], [1, 4], [2, 4], [1, 3], [1, 4], [1, 3], [2, 4]]</code><code class="nohighlight hljs ansi" style="display:block;">15-element Vector{Vector{Int64}}:
 [2, 4]
 [1, 4]
 [1, 3]
 [1, 4]
 [1]
 [2]
 [3]
 [4]
 [1, 4]
 [1, 4]
 [2, 4]
 [1, 3]
 [1, 4]
 [1, 3]
 [2, 4]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = [0, 2, 5, 8]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 0
 2
 5
 8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_tangent_hypergraph(H,A,P,4))</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{MaxPlus{Int64}}	Vector{MaxPlus{Int64}}
(4, Any[([2], [3]), ([4], [3]), ([1, 3], [2]), ([4], [3])], MaxPlus{Int64}[0 1 4 8; 0 2 4 7; 0 2 5 9; 0 1 3 6], [[2, 4], [1, 4], [1, 3], [2, 4]])</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; I = [-Inf 0 -Inf 1 -Inf -Inf; -Inf -4 -3 0 -Inf -Inf; -Inf -Inf -1 0 -6 -Inf; 0 -Inf -Inf -Inf -Inf -4; 0 -8 -Inf -Inf -Inf -3]</code><code class="nohighlight hljs ansi" style="display:block;">5×6 Matrix{Float64}:
 -Inf     0.0  -Inf     1.0  -Inf   -Inf
 -Inf    -4.0   -3.0    0.0  -Inf   -Inf
 -Inf   -Inf    -1.0    0.0   -6.0  -Inf
   0.0  -Inf   -Inf   -Inf   -Inf    -4.0
   0.0   -8.0  -Inf   -Inf   -Inf    -3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = [0, 1, 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 0
 1
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_tangent_hypergraph(I,P,3))</code><code class="nohighlight hljs ansi" style="display:block;">(3, Any[([2], [1]), ([3], [1]), ([1], [3])], MaxPlus{Float64}[⋅ 0.0 ⋅ 1.0 ⋅ ⋅; ⋅ -4.0 -3.0 0.0 ⋅ ⋅; 0.0 -8.0 ⋅ ⋅ ⋅ -3.0])</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M =  [0 1 3; 0 4 1; 0 9 4]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
 0  1  3
 0  4  1
 0  9  4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = [0, 1, 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 0
 1
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(stdout, &quot;text/plain&quot;, compute_tangent_hypergraph(M,P,3))</code><code class="nohighlight hljs ansi" style="display:block;">(3, Any[([3], [1]), ([2], [1]), ([2], [3]), ([1], [3])])</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>The algorithms implemented in TPLib are bases on the following papers.</p><p>[1] X. Allamigeon. Static analysis of memory manipulations by abstract interpretation – Algorithmics of tropical polyhedra, and application to abstract interpretation. PhD thesis. </p><p>[2] X. Allamigeon, S. Gaubert, E. Goubault. Computing the vertices of tropical polyhedra using directed hypergraphs. Discrete &amp; Computational Geometry, 49(2):247–279, 2013. E-print arXiv:0904.3436v4.</p><p>[3] X. Allamigeon, S. Gaubert, and R. D. Katz. Tropical polar cones, hypergraph transversals, and mean payoff games. Linear Algebra Appl., 435(7):1549–1574, 2011. E-print arXiv:1004.2778.</p><p>[4] X. Allamigeon and R.D. Katz. Minimal external representations of tropical polyhedra. Journal of Combinatorial Theory, Series A, 120(4):907–940, 2013.  Eprint arXiv:1205.6314.</p><p>[5] X. Allamigeon, S. Gaubert, E. Goubault. Inferring Min and Max Invariants Using Max-plus Polyhedra. Proceedings of the 15th International Static Analysis Symposium (SAS&#39;08). </p><p>[6] M. Develin and B. Sturmfels. Tropical convexity. Doc. Math., 9:1–27 (electronic), 2004. E-print arXiv:math.MG/0308254.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Installation</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 February 2023 13:37">Tuesday 14 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
